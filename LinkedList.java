package com.company;
Рефлексия на занятие 1: Не объявил класс как абстрактный. Не сделал комментарий к статусам. Не прописал категории к методам класса. Не прописал пред- и постусловия. Результат: код сделал, а идею занятия упустил.


2.1.

public abstract class LinkedList<T> {

    public final int CURSOR_NIL = 0; // курсор ещё не устанавливался
    public final int CURSOR_OK = 1; // курсор корректно установлен
    public final int CURSOR_ERR = 2; // список пуст

    public final int PUT_OK = 1; // последняя put_right() или put_left() отработала нормально
    public final int PUT_ERR = 2; // список пуст

    public final int REMOVE_OK = 1; // последняя remove() отработала нормально
    public final int REMOVE_ERR = 2; // список пуст

    public final int REPLACE_OK = 1; // последняя replace() отработала нормально
    public final int REPLACE_ERR = 2; // список пуст

    public final int FIND_NIL = 0; // поиск не начат
    public final int FIND_OK = 1; // последняя find() отработала нормально
    public final int FIND_ERR = 2; // узел с заданным значением отсутствует в списке

    public final int REMOVE_ALL_OK = 1; // последняя remove_all() отработала нормально
    public final int REMOVE_ALL_ERR = 2; // в списке нет ни одного узла с заданным значением

    // Конструктор
    // Предусловие:
    // Постуслвие: создан новый пустой список
    public LinkedList<T> LinkedList() {}
    // Команды
    // Предусловие: спиосок не пустой
    // Постусловие: курсор установлен на первый элемент списка
    public head() {} // установить курсор на первый узел в списке
    // Предусловие: список не пустой
    // Постусловие: курсор установлен на последний элемент списка
    public tail() {} // установить курсор на последний узел в списке
    // Предусловие: список не пустой
    // Постусловие: курсор сдвинут на один узел вправо
    public right() {} // сдвинуть курсор на один узел вправо
    // Предусловие:
    // Постусловие: в список вставлен новый элемент за текущим
    public put_right(значение) {} // вставить следом за текущим узлом новый узел с заданным значением
    // Предусловие:
    // Постусловие: в список вставлен новый элемент перед текущим
    public put_left(значение) {} // вставить перед текущим узлом новый узел с заданным значением
    // Предусловие: список не пустой
    // Постусловие: из списка удален текущий элемент
    public remove() {} // удалить текущий узел(курсор смещается к правому соседу, если он есть,в противном случае курсор смещается к левому соседу, если он есть)
    // Предусловие:
    // Постусловие: из списка удалены все элементы
    public clear() {} // очистить список
    // Предусловие:
    // Постусловие: добавлен новый элемент в хвост списка
    public add_tail(значение) {} // добавить новый узел в хвост списка
    // Предусловие: список не пустой
    // Постусловие: значение текущего элемента заменено на новое
    public replace(значение) {} // заменить значение текущего узла на заданное
    // Предусловие:
    // Постусловие: курсор установлен на следующий узел с искомым значением
    public find(значение) {} // установить курсор на следующий узел с искомым значением (по отношению к текущему узлу)
    // Предусловие:
    // Постусловие: из списка удалены все узлы с заданным значением
    public remove_all(значение) {} // удалить в списке все узлы с заданным значением

    // Запросы
    // Предусловие: список не пустой
    // Постусловие:
    public get() {} // получить значение текущего узла
    // Предусловие:
    // Постусловие:
    public size() {} // посчитать количество узлов в списке
    // Предусловие:
    // Постусловие:
    public is_head() {} // находится ли курсор в начале списка
    // Предусловие:
    // Постусловие:
    public is_tail() {} // находится ли курсор в конце списка
    // Предусловие:
    // Постусловие:
    public is_value() {} // установлен ли курсор на какой-либо узел в списке(по сути, непустой ли список)


    // дополнительные запросы:
    public int get_cursor_status() {} // возвращает значение CURSOR_*
    public int get_put_status() {} // возвращает значение PUT_*
    public int get_remove_status() {} // возвращает значение REMOVE_*
    public int get_replace_status() {} // возвращает значение REPLACE_*
    public int get_find_status() {} // возвращает значение FIND_*
    public int get_remove_all_status() {} // возвращает значение REMOVE_ALL*
}

2.2. Эффективная реализация подразумевает доступ к хвосту через специальный указатель, в противном случае нужно использовать right

2.3. Потому что это теперь выполняется с помощью find.
